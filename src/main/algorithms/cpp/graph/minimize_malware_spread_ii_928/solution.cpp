#include "../../head.h"
 

class SolutionWrongAnswerLastThree {
public:
    int minMalwareSpread(std::vector<std::vector<int>> const & graph, std::vector<int> const & initial) {
        std::unordered_map<int, std::set<int>> reshapeGraph;
        std::set<int> targetSet(initial.begin(), initial.end());
        int size = graph.size();
        for (int row = 0; row < size; row++) {
            for (int col = row + 1; col < size; col++) {
                if (graph[row][col]) {
                    reshapeGraph[row].emplace(col);
                    reshapeGraph[col].emplace(row);
                }
            }
        }
        std::queue<int> leafs;
        std::set<int> keys; // store the alone point
        for (auto const & pair : reshapeGraph) {
            if (1 == pair.second.size()) {
                leafs.emplace(pair.first);
            }
            if (targetSet.find(pair.first) != targetSet.end()) {
                keys.emplace(pair.first);
                targetSet.erase(pair.first);
            }
        }

        // the initial points are all alone
        if (keys.empty()) {
            return *(targetSet.begin());
        }

        std::swap(keys, targetSet);


        int layerSize = leafs.size();
        while (layerSize = leafs.size()) {
            std::set<int> laySet;
            while (layerSize-- > 0) {
                int cur = leafs.front(); leafs.pop();
                if (targetSet.find(cur) != targetSet.end()) {
                    laySet.emplace(cur);
                    targetSet.erase(cur);
                }
                if (targetSet.empty()) {
                    if (laySet.size() > 1 && keys.size() > 0) {
                        return *(keys.begin());
                    } else {
                        return *(laySet.begin());
                    }
                }
                for (auto val : reshapeGraph[cur]) {
                    reshapeGraph[val].erase(cur);
                    if (1 == reshapeGraph[val].size()) {
                        leafs.emplace(val);
                    }
                }
            }
        }
        return *(targetSet.begin());
    }
};

class SolutionBFS {
public:
    int minMalwareSpread(std::vector<std::vector<int>> const & graph, std::vector<int>  initial) {
        // plagiarizing from https://leetcode.com/problems/minimize-malware-spread-ii/discuss/217529/c%2B%2B-solution-bfs
        std::sort(initial.begin(), initial.end());
        int minInfected = graph.size(), ans = -1;
        for (int ele : initial) {
            int cnt = bfs(graph, initial, ele);
            if (cnt < minInfected) {
                minInfected = cnt;
                ans = ele;
            }
        }
        return ans;
    }
    // first, we remove the infected node, and count the others infect how many node
    int bfs(std::vector<std::vector<int>> const & graph,
            std::vector<int> const & initial,
            int ele) {
        std::queue<int> toVisit;
        std::set<int> visited = {ele}; // which means remove the node
        for (int node : initial) {
            if (node != ele) {
                toVisit.emplace(node);
            }
        }
        int cnt = 0;
        while (toVisit.size()) {
            int cur = toVisit.front(); toVisit.pop();
            if (visited.count(cur)) {
                continue;
            }
            visited.emplace(cur);
            cnt++;
            for (int i = 0; i < graph[cur].size(); i++) {
                if (i != cur && graph[cur][i]) {
                    toVisit.emplace(i);
                }
            }

        }
        return cnt;

    }

};

class SolutionBetterRumTime {
public:
    int minMalwareSpread(std::vector<std::vector<int>> const & graph, std::vector<int> & initial) {
        //this map stores maximum reduction in the number of infected nodes when a node is removed completely
        std::unordered_map<int, int> reduction;
        for (auto node : initial) {
            reduction[node] = 0;      //initializing
        }

        std::vector<bool> visited(graph.size(),false);
        for (int i = 0; i < graph.size(); i++) {
            if (visited[i] == false && reduction.find(i) == reduction.end()) { //starting bfs with a non-infected unvisited node

               int comp_size=0;                      //count of non-infected nodes
               std::unordered_set<int> infected_nodes;    //contains infected nodes
               std::queue<int> q;

               q.push(i);
               visited[i]=true;
               comp_size++;       //'i' is a non-infected node
               while (!q.empty()) {
                  // int s = q.size();
                  // while (s--) {
                     int node=q.front(); q.pop();
                     for (int j = 0; j < graph[node].size(); j++) {
                        if (graph[node][j] == 1 && visited[j] == false) { //unvisited node
                           if(reduction.find(j) != reduction.end()) { //infected
                              infected_nodes.insert(j);
                           } else {                                  //non-infected
                              q.push(j);
                              visited[j]=true;
                              comp_size++;
                           }
                        }
                     }
                  // }
               }

               if (infected_nodes.size() == 1) {
                   // the alone point and more than one point connected are all zero.
                   // delete them will be the same, the infected node will not be less
                   std::unordered_set<int>::iterator itr = infected_nodes.begin();
                   reduction[*itr] += comp_size;
               }
            }
        }

        int max_reduction=INT_MIN;
        int opt_node=INT_MAX;

        std::unordered_map<int,int>::iterator itr;
        for (itr = reduction.begin(); itr != reduction.end(); itr++) {
            if (max_reduction < itr->second) {
               max_reduction = itr->second;
               opt_node = itr->first;
            } else if (max_reduction == itr->second) {
               opt_node=min(opt_node,itr->first);
            }
        }
        return opt_node;
    }
};
