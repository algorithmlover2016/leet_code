#include "../../head.h"


class Solution {
public:
    int minMalwareSpread(std::vector<std::vector<int>> const & graph, std::vector<int> & initial) {
        // https://leetcode.com/problems/minimize-malware-spread/discuss/181129/C%2B%2BPython-Union-Found
        int size = graph.size();
        for (int index = 0; index < size; index++) {
            parent.emplace_back(index);
        }
        for (int row = 0; row < size; row++) {
            for (int col = row + 1; col < graph[row].size(); col++) {
                if (graph[row][col]) {
                    unionFind(row, col);
                }
            }
        }
        std::vector<int> unionPointSum(size, 0);
        std::vector<int> infectedPointSum(size, 0);
        for (int index = 0; index < size; index++) {
            unionPointSum[find(index)]++;
        }
        for (int ele : initial) {
            infectedPointSum[find(ele)]++;
        }
        // make sure will never select default value, because the others are negative
        std::vector<int> ans = {INT_MAX, 0};
        for (int ele : initial) {
            // std::cout << "original ans: " << ans[0] << "\t" << ans[1] << "\n";
            ans = std::min(ans, {(infectedPointSum[find(ele)] == 1) * (-unionPointSum[find(ele)]), ele});
            // std::cout << "change ans: " << ans[0] << "\t" << ans[1] << "\n";
        }
        return ans.back();

    }

private:
    int find(int x) {
        if (x != parent[x]) {
            parent[x] = find(parent[x]);
        }
        return parent[x];
    }

    void unionFind(int x, int y) {
        // int xp = find(x);
        // int yp = find(y);
        // if (xp != yp) {
        //     parent[xp] = yp;
        // }
        parent[find(x)] = find(y);
    }
    std::vector<int> parent;
};

class SolutionBetterRumtimeDFS {
    std::vector<std::vector<int>> G;
    int N;
    std::vector<bool> infected;
    std::vector<bool> visited;

    int current_size;
    std::vector<int> curr_infected;

    void dfs(int curr) {
        if (visited[curr]) {
            return;
        }
        visited[curr] = true;
        current_size++;

        if (infected[curr]) {
            curr_infected.emplace_back(curr);
        }

        for (int next = 0; next < N; next++) {
            if (G[curr][next] == 1) {
                dfs(next);
            }
        }
    }

public:
    int minMalwareSpread(std::vector<std::vector<int>> & graph, std::vector<int> & initial) {
        G=std::move(graph);
        N=G.size();
        infected = std::vector<bool>(N, false);
        for (int i: initial)  {
            infected[i] = true;
        }

        visited = std::vector<bool>(N, false);

        std::pair<int ,int> result = {-1, -1};
        for (int i = 0; i < N; i++) {
            if (visited[i]) {
                continue;
            }

            current_size = 0;
            curr_infected.clear();

            dfs(i);

            int sz = curr_infected.size();
            if (sz==0) {
                ;
            } else if (sz == 1) {
                int a = curr_infected[0];
                result = std::max(result, {current_size, -a});
            } else {
                int a = *std::min_element(curr_infected.begin(), curr_infected.end());
                result = std::max(result, {0, -a});
            }
        }
        return -result.second;
    }
};
