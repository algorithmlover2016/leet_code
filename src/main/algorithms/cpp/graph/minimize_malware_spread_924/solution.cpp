#include "../../head.h"


class Solution {
public:
    int minMalwareSpread(std::vector<std::vector<int>> const & graph, std::vector<int> & initial) {
        // https://leetcode.com/problems/minimize-malware-spread/discuss/181129/C%2B%2BPython-Union-Found
        int size = graph.size();
        for (int index = 0; index < size; index++) {
            parent.emplace_back(index);
        }
        for (int row = 0; row < size; row++) {
            for (int col = row + 1; col < graph[row].size(); col++) {
                if (graph[row][col]) {
                    unionFind(row, col);
                }
            }
        }
        std::vector<int> unionPointSum(size, 0);
        std::vector<int> infectedPointSum(size, 0);
        for (int index = 0; index < size; index++) {
            unionPointSum[find(index)]++;
        }
        for (int ele : initial) {
            infectedPointSum[find(ele)]++;
        }
        // make sure will never select default value, because the others are negative
        std::vector<int> ans = {INT_MAX, 0};
        for (int ele : initial) {
            // std::cout << "original ans: " << ans[0] << "\t" << ans[1] << "\n";
            ans = std::min(ans, {(infectedPointSum[find(ele)] == 1) * (-unionPointSum[find(ele)]), ele});
            // std::cout << "change ans: " << ans[0] << "\t" << ans[1] << "\n";
        }
        return ans.back();

    }

private:
    int find(int x) {
        if (x != parent[x]) {
            parent[x] = find(parent[x]);
        }
        return parent[x];
    }

    void unionFind(int x, int y) {
        // int xp = find(x);
        // int yp = find(y);
        // if (xp != yp) {
        //     parent[xp] = yp;
        // }
        parent[find(x)] = find(y);
    }
    std::vector<int> parent;
};
